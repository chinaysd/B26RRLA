C51 COMPILER V9.59.0.0   UART                                                              04/23/2019 19:04:06 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\obj\UART.obj
COMPILER INVOKED BY: E:\MDK\C51\BIN\C51.EXE C\UART.C OPTIMIZE(2,SPEED) BROWSE INCDIR(.\H;.\lib) DEBUG OBJECTEXTEND PRINT
                    -(.\lst\UART.lst) TABS(7) OBJECT(.\obj\UART.obj)

line level    source

   1          #include "UART.h"
   2          #include "SC92F836xB_C.H"
   3          
   4          
   5          unsigned char Uart1SendFlag,Uart1ReceiveFlag;
   6          unsigned char SLAVE;
   7          
   8          unsigned char RevData,RevNum,RevString[UART2_REVBUF_SIZE];
   9          
  10          /******************************************************************************
  11          *作者:PETER
  12          *日期:190308
  13          *描述:串口0初始化
  14          *返回:无
  15          *******************************************************************************/
  16          void uart_init(unsigned char Fsystem,unsigned int BaudRate_Count)
  17          {      
  18   1             P1CON &= 0xF3;   //TX/RX设置为输入带上拉
  19   1             P1PH  |= 0x0C;
  20   1             SCON  |= 0X50;   //设置通信方式为模式一，允许接收
  21   1             TMCON |= 0X02;
  22   1             TMOD  |= 0X20;
  23   1             PCON  |= 0X80;       //SMOD=1
  24   1             TH1 = (Fsystem*1000000/BaudRate_Count)>>8;         //波特率为T1的溢出时间；
  25   1             TL1 = Fsystem*1000000/BaudRate_Count;
  26   1             TR1 = 0;
  27   1             ET1 = 0;
  28   1             EUART = 0;     //开启Uart0中断
  29   1      }
  30          
  31          /*****************************************************
  32          *函数名称：void Uart1_Init(uint Freq,unsigned long int baud)
  33          *函数功能：Uart1中断初始化
  34          *入口参数：Freq-主频，baud-波特率
  35          *出口参数：Freq,baud
  36          *****************************************************/
  37          void Uart1_Init(unsigned char Freq,unsigned long int baud)
  38          {
  39   1             P2CON &= 0xFC;   //TX/RX设置为输入带上拉
  40   1             P2PH  |= 0x03;
  41   1             OTCON = 0xC0;    //串行接口SSI选择Uart1通信
  42   1             SSCON0 = 0x50;   //设置通信方式为模式一，允许接收
  43   1             SSCON1 = Freq*1000000/baud;   //波特率低位控制
  44   1             SSCON2 = (Freq*1000000/baud)>>8;   //波特率高位控制
  45   1             IE1 = 0x01;      //开启SSI中断
  46   1             EA = 1;       
  47   1      }
  48          
  49          /******************************************************************************
  50          *作者:PETER
  51          *日期:190308
  52          *描述:串口0发送函数
  53          *返回:无
  54          *******************************************************************************/
C51 COMPILER V9.59.0.0   UART                                                              04/23/2019 19:04:06 PAGE 2   

  55          static void UART_TX_byte(unsigned char Test1Data)
  56          {
  57   1         TI = 0;
  58   1         SBUF = Test1Data;
  59   1         while(!TI);
  60   1      }
  61          
  62          static unsigned char Uart1_SendData(UART1_PROTOCOL_TX *p)
  63          {
  64   1             static unsigned char i;
  65   1             for(i = 0; i < UART1_BUF_SIZE;i ++)
  66   1             {
  67   2                    UART_TX_byte(p->Uart1_Buf[i]);
  68   2             }
  69   1             return 0;
  70   1      }
  71          #if 1
  72          unsigned char Uart1_ProtocolSend(unsigned char addr1,unsigned char id1,unsigned int uart1data)
  73          {
  74   1             UART1_PROTOCOL_TX Uart1_buf;
  75   1             memset(&Uart1_buf,0,sizeof(Uart1_buf));
  76   1             Uart1_buf.Uart1_Format.ADDR1 = addr1;
  77   1             Uart1_buf.Uart1_Format.ID1      = id1; 
  78   1             Uart1_buf.Uart1_Format.DATA1  = UART1_Hight(uart1data);
  79   1             Uart1_buf.Uart1_Format.DATA2 = UART1_Low(uart1data);
  80   1             Uart1_buf.Uart1_Format.CHECKSUM1 = (unsigned char)(Uart1_buf.Uart1_Format.ADDR1+Uart1_buf.Uart1_Format.ID
             -1+Uart1_buf.Uart1_Format.DATA1+Uart1_buf.Uart1_Format.DATA2);
  81   1             Uart1_buf.Uart1_Format.STOP1 = 0x0d;
  82   1             Uart1_buf.Uart1_Format.STOP2 = 0x0a;
  83   1             return Uart1_SendData(&Uart1_buf);
  84   1      }
  85          #endif
  86          /******************************************************************************
  87          *作者:PETER
  88          *日期:190308
  89          *描述:串口1发送函数
  90          *返回:无
  91          *******************************************************************************/
  92          
  93          static void Uart1_Tx_Byte(unsigned char Test2Data)
  94          {
  95   1             SSDAT = Test2Data;
  96   1             while(!Uart1SendFlag);
  97   1             Uart1SendFlag = 0;
  98   1      }
  99          
 100          static unsigned char Uart2_SendData(UART2_PROTOCOL_TX *p)
 101          {
 102   1             static unsigned char i;
 103   1             for(i = 0 ;i < UART2_BUF_SIZE;i ++)
 104   1             {
 105   2                    Uart1_Tx_Byte(p->Uart2_Buf[i]);
 106   2             }
 107   1             return 0;
 108   1      }
 109          
 110          #if 1
 111          unsigned char Uart2_ProtocolSend(unsigned char addr2,unsigned char id2,unsigned int uart2data)
 112          {
 113   1             UART2_PROTOCOL_TX Uart2_buf;
 114   1             memset(&Uart2_buf,0,sizeof(Uart2_buf));
 115   1             Uart2_buf.Uart2_Format.UART2_ADDR2 = addr2;
C51 COMPILER V9.59.0.0   UART                                                              04/23/2019 19:04:06 PAGE 3   

 116   1             Uart2_buf.Uart2_Format.UART2_ID2      = id2;
 117   1             Uart2_buf.Uart2_Format.UART2_DATA1 = UART2_Hight(uart2data);
 118   1             Uart2_buf.Uart2_Format.UART2_DATA2 = UART2_Low(uart2data);
 119   1             Uart2_buf.Uart2_Format.UART2_CHECKSUM2 = (unsigned char)(Uart2_buf.Uart2_Format.UART2_ADDR2+Uart2_buf.Uar
             -t2_Format.UART2_ID2+Uart2_buf.Uart2_Format.UART2_DATA1+Uart2_buf.Uart2_Format.UART2_DATA2);
 120   1             Uart2_buf.Uart2_Format.UART2_STOP1 = 0x0d;
 121   1             Uart2_buf.Uart2_Format.UART2_STOP2 = 0x0a;
 122   1             return Uart2_SendData(&Uart2_buf);
 123   1      }
 124          #endif
 125          /******************************************************************************
 126          *作者:PETER
 127          *日期:190308
 128          *描述:串口1接收函数
 129          *返回:无
 130          *******************************************************************************/
 131          unsigned char Rev_Data(void)
 132          {
 133   1          SLAVE = SSDAT;
 134   1          return SLAVE;
 135   1      }
 136          
 137          unsigned char RevData_If(void)
 138          {
 139   1             if(RevNum & 0x80)
 140   1             {
 141   2                    RevNum = 0x00;
 142   2                    return 1;
 143   2             }
 144   1             else
 145   1             {
 146   2                    return 0;
 147   2             }
 148   1      }
 149          
 150          static void RevData_Handle(void)
 151          {
 152   1             RevData = Rev_Data();
 153   1             if(0 == (RevNum & 0x80))
 154   1             {
 155   2                    if(RevNum & 0x40)
 156   2                    {
 157   3                           if(RevData == 0x0a)
 158   3                           {
 159   4                                  RevNum = 0x80;
 160   4                           }
 161   3                           else
 162   3                           {
 163   4                                  RevNum = 0x00;
 164   4                           }
 165   3                    }
 166   2                    else
 167   2                    {
 168   3                           if(RevData == 0x0d)
 169   3                           {
 170   4                                  RevNum = 0x40;
 171   4                           }
 172   3                           else
 173   3                           {
 174   4                                  RevString[RevNum]=RevData;
 175   4                                  RevNum ++;
 176   4                                  if(RevString[0] != 0xfa)
C51 COMPILER V9.59.0.0   UART                                                              04/23/2019 19:04:06 PAGE 4   

 177   4                                  {
 178   5                                         RevNum = 0;
 179   5                                  }
 180   4                                  if(RevNum > UART2_REVBUF_SIZE)
 181   4                                  {
 182   5                                         RevNum = 0;
 183   5                                  }
 184   4                           }
 185   3                    }
 186   2             }
 187   1      }
 188          
 189          /******************************************************************************
 190          *作者:PETER
 191          *日期:190308
 192          *描述:串口1中断处理函数
 193          *返回:无
 194          *******************************************************************************/
 195          
 196          void Uart1_Int() interrupt 7   //Uart1中断函数
 197          {
 198   1             if(SSCON0&0x02)    //发送标志位判断
 199   1             {
 200   2                    SSCON0 &= 0xFD;
 201   2                    Uart1SendFlag = 1;
 202   2             }
 203   1             if((SSCON0&0x01))  //接收标志位判断
 204   1             {
 205   2                    SSCON0 &= 0xFE;
 206   2                    Uart1ReceiveFlag = 1;
 207   2             }      
 208   1             RevData_Handle();
 209   1      }
 210          
 211          
 212          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    661    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      38
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
